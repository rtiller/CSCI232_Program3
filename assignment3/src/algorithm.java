/*
 * Authors: Jake O'Malley, Robert Tiller
 * Date: 4/10/2018
 * Overview:
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;

public class algorithm
{
    public int size = 0;
    public String[] label;//for our label array
    public int[][] matrix;//for our matrix array
    public int minEdge = 0;
    
    public algorithm()//runs every time the algorithm is created in the driver. Reads out .txt file and generates a 2D array for us to work with in our algorithms
    {
        String line;
                Path file;
                file = FileSystems.getDefault().getPath("src", "matrix.txt");
                
                try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)){
                    //
                    //Creating a String array for Labes and itering how many we have
                    //
                    line = null;
                    line = reader.readLine();
                    String[] labelArray = line.split(",");//scans the first line of our TXT document for our label array and size of matrix
                    size = labelArray.length;//keeping track of label array size so that we can create arrays for label and the matrix
                    label = new String[size];// creating new string of the labelArray size in order to create our global label array
                    label = labelArray;//assigning labelArray (generated by the buffered reader) to our global label array
                    
                    //
                    //Creating a Int array for matrix from the rest of the .txt document
                    //
                    int x;
                    int i=0;
                    int[] matrixTemp = new int[120];
                    
                    int itr = 0;
                    matrix  = new int[size][size];
                    while ((line = reader.readLine()) != null){
                        String[] array = line.split(",");
                        
                        for(int k = 0; k < size; k++)
                        {
                            matrix[itr][k] = (Integer.parseInt(array[k]));
                        }
                        itr++;
                    }
                }catch (IOException x){
            System.err.format("IOException: %s%n", x);
        }
    }
    public void printLabelArray()
    {
        for(int i = 0; i < label.length; i++)
        {
            System.out.print(label[i] + " , ");            
        }
        System.out.println("\nSize of label array is " + size);
        System.out.println("And size of matrix array will be " + size + "x" + size);
    }
    public void printIntArray()
    {
        System.out.println("Printing Matrix Array: ");  
       
        for(int j = 0; j <= size-1; j++)
        {
            for(int k = 0; k <= size-1; k++)
            {
                if(matrix[j][k] == 999){
                    System.out.print("i ");
                }
                else{
                    System.out.print(matrix[j][k] + " ");
                }
            }
            System.out.println();
        }
    }
    public void printMinEdge(int x)
    {
        System.out.print("Printing Min Edge Value: ");  
        // For reverse of natural order i.e. largest to smallest
        // If you want the natural order don't use the Collections.reverseOrder() comparator
        Queue<Integer> queue = new PriorityQueue<Integer>(size);
        for(int j = 0; j <= size-1; j++)
        {
            queue.addAll(Arrays.asList(matrix[x][j]));
        }
        int test = queue.remove();
        System.out.print("\nMin edge value is ");
        System.out.println(test);
    }
/*
--------------------------------------------------------------------------------------- 
                           Prims_Algorithm
---------------------------------------------------------------------------------------     
*/
    public void Prims() 
    {
        PriorityQueue<Integer> marked = new PriorityQueue<>(matrix.length);  //holds marked vertices
        PriorityQueue<Integer> unMarked = new PriorityQueue<>(matrix.length); //holds unmarked vertices
        //new 2D int array to hold Vertices
        int[][] minSpanningTree = new int[matrix.length][matrix.length];
        int min = 999;
        int minDex = 0;
        int initial = 3;//starting with random node
        int diag = 0;//for label print

        unMarked.remove(initial);
        marked.add(initial);
        
        //ini. unmarked queue
        for (int i = 0; i < matrix.length; i++) 
        {
            unMarked.add(i);
        }
        
        //loops through every adjacent vertex of initial node and choose min
        for (int i = 0; i < matrix.length; i++) 
        {
            int adjWeight = matrix[initial][i];
            if (adjWeight < min)
            {
                min = adjWeight;
                minDex = i;
            }
        }

        unMarked.remove(minDex);//removes the new vertex from unmarked priority queue
        marked.add(minDex);//adds the new vertex to marked priority queue

        //adds vertices to the minSpanningTree array
        minSpanningTree[initial][minDex] = min;
        minSpanningTree[minDex][initial] = min;

        //for all marked vertecies in the matrix loop through the adjacent, unmarked vertices and find minimum edges
        while(unMarked.size() > 0)
        {
            min = 999;
            int iter = 0;
            for(Integer element : marked)
            {
                iter++;
                for (int i = 0; i < matrix.length; i++) 
                {
                    if (unMarked.contains(i))
                    {
                        if (matrix[element][i] < min) 
                        {
                            min = matrix[element][i];
                            minDex = i;
                        }
                    }
                }
                if (iter == marked.size())
                {
                    minSpanningTree[element][minDex] = min;
                    minSpanningTree[minDex][element] = min;
                }
            }
            unMarked.remove(minDex);
            marked.add(minDex);
        }

        System.out.println("Prims Matrix:");
        //print labels.
        for (int i = diag; i < minSpanningTree.length; i++) {
            for (int j = diag; j < minSpanningTree.length; j++) 
            {
                if(minSpanningTree[i][j] >0)
                System.out.print(label[i]+label[j]+" ");
            }
            diag++;
        }
    }
    
/*
--------------------------------------------------------------------------------------- 
                           Kruskal's_Algorithm
---------------------------------------------------------------------------------------     
*/
 public void Kruskal() 
    {
        int[][] d = new int[size][size];
        int i,j;
        int fillMST = 0;
        int[][] MST = new int[matrix.length][matrix.length];
        int[] c_u = new int[size];
        int[] c_v = new int[size];
        int[] c_merge = new int[size];
        
        Comparator<edge> Comparator = new edgeComparator();
        PriorityQueue<edge> queue = new PriorityQueue<>(matrix.length, Comparator);  //holds marked vertices
        
        for(i = 0; i < size; i++){
            for(j = 0; j < size; j++){
                //d[i][j] = matrix[i][j];
                edge temp = new edge(matrix[i][j], i,j);//create edge instances as we scan in from the matrix //////idk why we are creating a duplicate array for matrix
                queue.add(temp);//populate queue
                
            }
        }
        System.out.println("Kruskals Algorithm");
        while(fillMST < (label.length*2)-1)
        {
            int u,v;
            if(queue.peek() != null)
            {
                edge x = queue.poll();
                u = x.from;
                v = x.to;


                c_u[u] = u;
                c_v[v] = v;

                if(c_u[u] != c_v[v])//C(u) != C(v)
                {
                    MST[x.to][x.from] = x.weight;//add edge to T
                    //merge C(u) and C() into one cluster;

                    //System.out.print(label[u]+label[v] + " " );
                }
            }
            fillMST++;
        }
        
             //print labels.
            int diag = 0;
            for ( i = diag; i < MST.length; i++) 
            {
                for (j = diag; j < MST.length; j++) 
                {
                    if(MST[i][j] >0)
                    System.out.print(label[i]+label[j]+" ");
                }
                diag++;
            }
            System.out.println();
        
}
 
    public class edgeComparator implements Comparator<edge>
    {
       public int compare(edge a, edge b)
       {
           if (a.weight < b.weight)
               return -1;  
           else if (a.weight > b.weight)
               return 1;
           else
           return 0;
       }
    } 

   public class edge
   {
        public int weight=0;
        public int to = 0;
        public int from = 0;

        public edge(int x, int y, int z)
       {
        weight = x;
        to = y;
        from = z;
       }
        public int weight()
        {
            return weight;
        }
   }
}



   



