/*
 * Authors: Jake O'Malley, Robert Tiller
 * Date: 4/10/2018
 * Overview:
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;

public class algorithm
{
    public int size = 0;
    public String[] label;//for our label array
    public int[][] matrix;//for our matrix array
    public int minEdge = 0;
    
    

    public algorithm()//runs every time the algorithm is created in the driver. Reads out .txt file and generates a 2D array for us to work with in our algorithms
    {
        String line;
                Path file;
                file = FileSystems.getDefault().getPath("src", "matrix.txt");
                
                try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)){
                    //
                    //Creating a String array for Labes and counting how many we have
                    //
                    line = null;
                    line = reader.readLine();
                    String[] labelArray = line.split(",");//scans the first line of our TXT document for our label array and size of matrix
                        /*Origional print testing buffered reader
                        for(int i = 0; i < labelArray.length; i++){
                            System.out.println(labelArray[i]); 
                        }*/
                    size = labelArray.length;//keeping track of label array size so that we can create arrays for label and the matrix
                    label = new String[size];// creating new string of the labelArray size in order to create our global label array
                    label = labelArray;//assigning labelArray (generated by the buffered reader) to our global label array
                    
                    //
                    //Creating a Int array for matrix from the rest of the .txt document
                    //
                    int x;
                    int i=0;
                    int[] matrixTemp = new int[120];
                    while ((x = reader.read()) != -1) 
                    {
                        if(x >= 48)//converting ascii values to INTS and ignoring ","
                        {
                            int numericValue = Character.getNumericValue(x);
                            matrixTemp[i]= numericValue;
                            //System.out.println("Do something with " + numericValue);
                            i++;
                        }
                    }
                    int itr = 0;
                    matrix  = new int[size][size];
                    for(int j = 0; j <= size-1; j++)
                    {
                        for(int k = 0; k <= size-1; k++)
                        {
                            matrix[j][k] = matrixTemp[itr];
                            itr++;
                        }
                    }
                    
                    //
                    //Creating a 2D array from global arrays Matrix and Label
                    //
                    /*
                    adjacencyMatrix = new char[size][size+1];//initializing the 2D array for the correct size
                    int itr = 0;
                    for(int j = 0; j <= size; j++)
                    {
                        adjacencyMatrix[j][0] = label[j];
                        for(int k = 1; k <= size+1; k++)
                        {
                            adjacencyMatrix[j][k] = (char) matrix[itr];
                            itr++;
                        }
                    }*/
                    
                }catch (IOException x){
            System.err.format("IOException: %s%n", x);
        }
    }
    
    public void printLabelArray()
    {
        for(int i = 0; i < label.length; i++)
        {
            System.out.print(label[i] + " , ");            
        }
        System.out.println("\nSize of label array is " + size);
        System.out.println("And size of matrix array will be " + size + "x" + size + " (36) ");
    }
    public void printIntArray()
    {
        System.out.print("Printing Matrix Array: ");  
       
        for(int j = 0; j <= size-1; j++)
        {
            for(int k = 0; k <= size-1; k++)
            {
                int x = matrix[j][k];
                System.out.print(x + " , ");
            }
        }
    }
    
    public void printMinEdge(int x)
    {
        System.out.print("Printing Min Edge Value: ");  
        // For reverse of natural order i.e. largest to smallest
        // If you want the natural order don't use the Collections.reverseOrder() comparator
        Queue<Integer> queue = new PriorityQueue<Integer>(size);
        for(int j = 0; j <= size-1; j++)
        {
            queue.addAll(Arrays.asList(matrix[x][j]));
        }
        int test = queue.remove();
        System.out.print("\nMin edge value is ");
        System.out.println(test);
    }
    
/*
--------------------------------------------------------------------------------------- 
                           Prims_Algorithm
---------------------------------------------------------------------------------------     
*/    
public class Prims_Algorithm 
{
    /*Pseudocode:
    algorithm: An undirected, weighted, connected graph G with n vertices and m edges
    output: A minimum spanning tree T for G
    
    pick any vertex s of G
    D[s] = 0
    for each vertex v!= s do
        D[v] = 'infinity'
    initialize T = 'null'?
    initialize a priority queue Q with an entry (D[v],v) for each vertex v
    For each vertex v, maintain connect(v) as the edge achieving D[v](if any)
    while Q is not empty do
        Let u be the value of the entry returned by Q.removeMin()
        connect vertex u to T using edge connect(e)
        for each edge e' = (u,v) such that v is in Q do
    {check if edge (u,v) better connects v to T}
            if w(u,v) < D[v] then
                D[v] = w(u,v)
                connect(v) = e'
                change the key of vertex v in Q to D[v]
    return the tree T
    */
    /*
    int vertex;
    public Prims_Algorithm()//runs every time the algorithm is created in the driver. Reads out .txt file and generates a 2D array for us to work with in our algorithms
    {
        vertex = 0;
        while(matrix[i] != matrix[vertex])
        {
            
        }
    }
*/
}    
  

